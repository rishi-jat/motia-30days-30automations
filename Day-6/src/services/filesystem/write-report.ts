/**
 * File System Service
 * Writes incident reports to markdown files
 */

import { writeFile } from 'fs/promises';
import { FileWriteError } from '../../errors/log-analyzer.errors';
import type { IncidentReport } from '../llm/analyzer';
import type { ParsedLogs } from '../logs/parser';

export interface WriteReportOptions {
    report: IncidentReport;
    parsed: ParsedLogs;
    isFallback?: boolean;
}

/**
 * Write incident report to markdown file
 */
export async function writeIncidentReport(options: WriteReportOptions): Promise<string> {
    try {
        const outputPath = process.env.OUTPUT_PATH || './INCIDENT_REPORT.md';
        const markdown = generateMarkdown(options);

        await writeFile(outputPath, markdown, 'utf-8');

        return outputPath;
    } catch (error) {
        throw new FileWriteError(
            `Failed to write incident report: ${error instanceof Error ? error.message : 'Unknown error'}`
        );
    }
}

/**
 * Generate markdown content from incident report
 */
function generateMarkdown(options: WriteReportOptions): string {
    const { report, parsed, isFallback } = options;

    const severityEmoji = {
        LOW: 'ðŸŸ¢',
        MEDIUM: 'ðŸŸ¡',
        HIGH: 'ðŸŸ ',
        CRITICAL: 'ðŸ”´',
    };

    return `# ðŸ“‹ Incident Report

${isFallback ? '> âš ï¸ **Note:** This report was generated using fallback analysis (LLM unavailable)\n' : ''}

## ${report.title}

| Field | Value |
|-------|-------|
| **Severity** | ${severityEmoji[report.severity]} ${report.severity} |
| **Timestamp** | ${report.timestamp} |
| **Generated By** | ${report.generatedBy === 'llm' ? 'ðŸ¤– AI Analysis' : 'ðŸ“ Fallback Analysis'} |

---

## ðŸ“ Summary

${report.summary}

---

## ðŸ” Root Cause

${report.rootCause}

---

## ðŸ“ Stack Frame Responsible

\`\`\`
${report.stackFrameResponsible || 'Not available'}
\`\`\`

---

## ðŸ’¥ Impact

${report.impact}

---

## ðŸ› ï¸ Fix Plan

${report.fixPlan}

---

## ðŸ›¡ï¸ Prevention Plan

${report.preventionPlan}

---

## ðŸ§© Affected Components

${report.affectedComponents.length > 0
            ? report.affectedComponents.map(c => `- \`${c}\``).join('\n')
            : '- None identified'}

---

## ðŸ“Š Log Statistics

| Metric | Value |
|--------|-------|
| Total Lines | ${parsed.summary.totalLines} |
| Error Count | ${parsed.summary.errorCount} |
| Warning Count | ${parsed.summary.warningCount} |
| Has Stack Trace | ${parsed.summary.hasStackTrace ? 'âœ… Yes' : 'âŒ No'} |

---

## ðŸ“œ Error Messages

${parsed.errors.slice(0, 5).map((err, i) => `
### Error ${i + 1}
**Timestamp:** ${err.timestamp || 'N/A'}
\`\`\`
${err.message}
\`\`\`
`).join('\n') || 'No errors captured'}

---

## ðŸ“š Stack Trace

${parsed.stackFrames.length > 0
            ? '```\n' + parsed.stackFrames.slice(0, 10).map(f =>
                `at ${f.method} (${f.file}:${f.line}${f.column ? `:${f.column}` : ''})`
            ).join('\n') + '\n```'
            : 'No stack trace available'}

---

**Generated by Day-6 AI Log Analyzer Workflow** ðŸ¤–
`;
}
